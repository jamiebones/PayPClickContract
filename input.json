{
  "language": "Solidity",
  "sources": {
    "contracts/PayToClickContract.sol": {
      "content": "//SPDX-License-Identifier:MIT\r\npragma solidity ^0.8.15;\r\n\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n//import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"./ControlContract.sol\";\r\nimport \"./Lib.sol\";\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\n//vusd contract address : 0x8694A1A789133c94aA3c95B80c852583628A93b6\r\n\r\ncontract PayToClickContract {\r\n    //storage\r\n\r\n    using SharedStructs for *;\r\n\r\n    //Declare control contract\r\n    ControlContract private controlContract;\r\n\r\n\r\n    //where to place the Member in the tree\r\n    uint256 private currentIndex;\r\n\r\n    //click reward in cents $1 token VUSD\r\n\r\n    address private ownerWallet; //wallet of owner\r\n\r\n    address private tokenManager; //wallet of owner\r\n\r\n    //payment wallet\r\n    address[] private adminWallet;\r\n\r\n    uint256 public transactionTax = 1; //1 VNT\r\n\r\n    //0=> owner wallet %\r\n    //1=> admin wallet %\r\n\r\n    //the array to hold the price of the membership packages of elite, premium and platinum\r\n\r\n    IERC20 private VUSDTOKEN;\r\n\r\n    //array of nodes\r\n    SharedStructs.Node[100000] public nodes;\r\n    //0=> elite plan : 1=> premium : 2=> platinum\r\n\r\n    //SIMPLE QUEUE VARIABLE\r\n    SharedStructs.Node[] private Nodequeue;\r\n\r\n    //mappings\r\n    mapping(address => Member) public members;\r\n\r\n    mapping(address => SpillNode[]) private spillNodeArray; //the array that contains all spill nodes;\r\n\r\n    mapping(address => SharedStructs.Node[]) public memberSubNode;\r\n    mapping(address => uint256) public smbBonusEarned;\r\n    //admin VNT purse in the main contract\r\n    mapping(address => uint256) private adminVNTPurse;\r\n\r\n    //withdrawal history\r\n    // mapping(address => History[]) private withdrawalHistory;\r\n\r\n    uint256[] public membershipPackagePriceArray = [20, 100, 1000];\r\n\r\n    //0=> elite plan : 1=> premium : 2=> platinum\r\n    SharedStructs.MembershipPackage[] private membershipPackagesArray;\r\n\r\n    struct Member {\r\n        address walletAddress;\r\n        address upline; //the referral address\r\n        uint256 slotIndex; //the index in the array\r\n        uint256 uplineIndex; //the index of the upline\r\n        //direct referral bonus earned\r\n        uint256 directRefEarnings; //10% of package size\r\n        uint256 clickRewardEarned; //total number of clicks\r\n        uint256 totalEarnings; //total amount they have earned\r\n        uint256 firstClickToday; //the firsttime the advert was clicked\r\n        //array of the node that has given member SMB\r\n        uint256[] smbNodesReceived;\r\n        MembershipType membershipType;\r\n        bool status; //if the member is active or not\r\n        uint8 clickCount; //how many times they have clicked in 24 hours\r\n    }\r\n\r\n    struct SpillNode {\r\n        address memberAddress;\r\n        uint256 points;\r\n    }\r\n\r\n    constructor(\r\n        address owner,\r\n        address tokenAddress,\r\n        address payable controlContractAddress,\r\n        //adminwallets\r\n        address[] memory wallets,\r\n        address tokenManagerContractAddress\r\n    ) {\r\n        //set all default packages value;\r\n        //set all default membership plan\r\n        ownerWallet = owner;\r\n        tokenManager = tokenManagerContractAddress;\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            if (i == 0) {\r\n                SharedStructs.MembershipPackage memory newPackage;\r\n                newPackage.dailyClicks = 10;\r\n                newPackage.packagePoints = 1;\r\n                newPackage.maximumIncome = 300;\r\n                membershipPackagesArray.push(newPackage);\r\n            } else if (i == 1) {\r\n                SharedStructs.MembershipPackage memory newPackage;\r\n                newPackage.dailyClicks = 20;\r\n                newPackage.packagePoints = 5;\r\n                newPackage.maximumIncome = 1500;\r\n                membershipPackagesArray.push(newPackage);\r\n            } else if (i == 2) {\r\n                SharedStructs.MembershipPackage memory newPackage;\r\n                newPackage.dailyClicks = 30;\r\n                newPackage.packagePoints = 50;\r\n                newPackage.maximumIncome = 6000;\r\n                membershipPackagesArray.push(newPackage);\r\n            }\r\n        }\r\n\r\n        //set admin adminWallet\r\n        for (uint8 i = 0; i < wallets.length; i++) {\r\n            adminWallet.push(wallets[i]);\r\n        }\r\n\r\n        controlContract = ControlContract(controlContractAddress);\r\n        //set initial pyramid\r\n        SharedStructs.Node memory newNode;\r\n        newNode.memberAddress = owner;\r\n        newNode.index = 0;\r\n        newNode.leftPointer = 0;\r\n        newNode.rightPointer = 0;\r\n\r\n        //save the node\r\n        nodes[0] = (newNode); //index will be 0\r\n\r\n        //save the Member details\r\n        Member memory newMember;\r\n        newMember.directRefEarnings = 0;\r\n        newMember.smbNodesReceived = new uint256[](0);\r\n        newMember.walletAddress = owner;\r\n        newMember.slotIndex = 0;\r\n        newMember.upline = address(0);\r\n        newMember.uplineIndex = 0;\r\n        newMember.membershipType = MembershipType.PLATINUM;\r\n        newMember.status = true;\r\n        newMember.clickRewardEarned = 0;\r\n        newMember.firstClickToday = 0;\r\n        newMember.clickCount = 0;\r\n        newMember.totalEarnings = 0;\r\n        members[owner] = newMember;\r\n        //increment the currentIndex\r\n        currentIndex++;\r\n        //save the token address in a variable\r\n        VUSDTOKEN = IERC20(tokenAddress);\r\n    }\r\n\r\n    function buyMembershipPlan(uint256 planIndex, address referral) public {\r\n        //check if the referral is valid if not valid referral is the owner with index 0;\r\n        if (referral == address(0)) {\r\n            referral = nodes[0].memberAddress;\r\n        }\r\n        //check if the person has the token to be able to buy the plan;\r\n        if (members[referral].walletAddress == address(0)) {\r\n            referral = nodes[0].memberAddress;\r\n        }\r\n\r\n        if (members[msg.sender].walletAddress != address(0)) {\r\n            revert(\"1W\");\r\n        }\r\n\r\n        uint256 planPrice = membershipPackagePriceArray[planIndex];\r\n        planPrice = planPrice * 1 ether;\r\n\r\n        uint256 planPoints = membershipPackagesArray[planIndex].packagePoints;\r\n        //insert member into nodes\r\n        (uint256 insertIndex, bool canInsert) = _insertMemberIntoNode(\r\n            referral,\r\n            planPoints\r\n        );\r\n\r\n        //create a new Member\r\n        Member memory newMember;\r\n        newMember.upline = referral;\r\n        if (canInsert) {\r\n            newMember.slotIndex = insertIndex;\r\n        } else {\r\n            //cannot insert just put a random value\r\n            newMember.slotIndex = 1000000;\r\n        }\r\n\r\n        uint256 referralSlot = members[referral].slotIndex;\r\n        newMember.uplineIndex = referralSlot;\r\n        newMember.directRefEarnings = 0;\r\n        newMember.walletAddress = msg.sender;\r\n        newMember.clickRewardEarned = 0;\r\n        newMember.firstClickToday = 0;\r\n        newMember.smbNodesReceived = new uint256[](0);\r\n        newMember.totalEarnings = 0;\r\n        MembershipType memberType;\r\n        if (planIndex == 0) {\r\n            memberType = MembershipType.ELITE;\r\n        } else if (planIndex == 1) {\r\n            memberType = MembershipType.PREMIUM;\r\n        } else if (planIndex == 2) {\r\n            memberType = MembershipType.PLATINUM;\r\n        }\r\n        newMember.membershipType = memberType;\r\n        newMember.status = true;\r\n        newMember.clickCount = 0;\r\n\r\n        members[msg.sender] = newMember;\r\n\r\n        uint256 amountToShare = (planPrice * 10) / 100;\r\n        uint256 amountToContract = (planPrice * 90) / 100;\r\n\r\n        //10% bonus\r\n        uint256 directRefBonus = (planPrice * 10) / 100; //the bonus keep for the upline\r\n        //add to the direct ref bonus\r\n        members[referral].directRefEarnings =\r\n            members[referral].directRefEarnings +\r\n            directRefBonus;\r\n        //add the index to the\r\n        // if (canInsert) {\r\n        //     //you only add the confirm node to the invites\r\n        //     members[referral].invites.push(insertIndex);\r\n        // }\r\n        shareTokenFeeToAdmin(amountToShare);\r\n\r\n        VUSDTOKEN.transferFrom(msg.sender, tokenManager, amountToContract);\r\n        //require(success, \"transfer failed\");\r\n    }\r\n\r\n    function _insertMemberIntoNode(address referral, uint256 points)\r\n        private\r\n        returns (uint256 index, bool canInsert)\r\n    {\r\n        //get the referral slotNumber\r\n        uint256 referralSlot = members[referral].slotIndex;\r\n        //get the referral node and see if the children position is filled;\r\n        if (referralSlot == 1000000) {\r\n            SpillNode memory spillNode;\r\n            spillNode.memberAddress = msg.sender;\r\n            spillNode.points = points;\r\n            //add the spillNode to the array\r\n            spillNodeArray[referral].push(spillNode);\r\n            return (1000000, false);\r\n        }\r\n        SharedStructs.Node memory referralNode = nodes[referralSlot];\r\n        if (referralNode.memberAddress != address(0)) {\r\n            //we have a node present.\r\n            //check if the leftchild is empty\r\n            if (referralNode.leftPointer == 0) {\r\n                //we can add the new Node here\r\n                uint256 newLeftIndex = referralSlot * 2 + 1;\r\n                SharedStructs.Node memory newNode;\r\n                newNode.index = newLeftIndex;\r\n                newNode.leftPointer = 0;\r\n                newNode.rightPointer = 0;\r\n                newNode.memberAddress = msg.sender;\r\n                newNode.points = points;\r\n                nodes[newLeftIndex] = newNode;\r\n                //update the parent nodes reference here\r\n                nodes[referralSlot].leftPointer = newLeftIndex;\r\n                //increment the currentIndex\r\n                currentIndex++;\r\n                return (newLeftIndex, true);\r\n                //return\r\n            } else if (referralNode.rightPointer == 0) {\r\n                //we can add it here\r\n                uint256 newRightIndex = referralSlot * 2 + 2;\r\n                SharedStructs.Node memory newNode;\r\n                newNode.index = newRightIndex;\r\n                newNode.leftPointer = 0;\r\n                newNode.rightPointer = 0;\r\n                newNode.memberAddress = msg.sender;\r\n                newNode.points = points;\r\n                nodes[newRightIndex] = newNode;\r\n                //update the parent nodes reference here\r\n                nodes[referralSlot].rightPointer = newRightIndex;\r\n                //increment the currentIndex\r\n                currentIndex++;\r\n                return (newRightIndex, true);\r\n            } else {\r\n                //nothing works add it to spillNode spillNodeArray\r\n                SpillNode memory spillNode;\r\n                spillNode.memberAddress = msg.sender;\r\n                spillNode.points = points;\r\n                //add the spillNode to the array\r\n                spillNodeArray[referral].push(spillNode);\r\n                return (1000000, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function renewSubScription() public payable {\r\n        Member memory member = members[msg.sender];\r\n        uint256 maximumEarnings;\r\n        uint256 planPrice;\r\n        uint256 packagePoints;\r\n\r\n        if (member.membershipType == MembershipType.ELITE) {\r\n            maximumEarnings = membershipPackagesArray[0].maximumIncome;\r\n            planPrice = membershipPackagePriceArray[0];\r\n            packagePoints = membershipPackagesArray[0].packagePoints;\r\n        } else if (member.membershipType == MembershipType.PLATINUM) {\r\n            maximumEarnings = membershipPackagesArray[2].maximumIncome;\r\n            planPrice = membershipPackagePriceArray[2];\r\n            packagePoints = membershipPackagesArray[2].packagePoints;\r\n        } else if (member.membershipType == MembershipType.PREMIUM) {\r\n            maximumEarnings = membershipPackagesArray[1].maximumIncome;\r\n            planPrice = membershipPackagePriceArray[1];\r\n            packagePoints = membershipPackagesArray[1].packagePoints;\r\n        }\r\n        maximumEarnings = maximumEarnings * 1 ether;\r\n        \r\n        if (\r\n            member.walletAddress == address(0) ||\r\n            member.totalEarnings < maximumEarnings\r\n        ) {\r\n            revert(\"o\");\r\n        }\r\n        planPrice = planPrice * 1 ether;\r\n        uint256 amountToShare = (planPrice * 10) / 100;\r\n        uint256 amountToContract = (planPrice * 90) / 100;\r\n\r\n        //10% bonus\r\n        uint256 directRefBonus = (planPrice * 10) / 100;\r\n        //add to the direct ref bonus\r\n        members[member.upline].directRefEarnings =\r\n            members[member.upline].directRefEarnings +\r\n            directRefBonus;\r\n\r\n        //set the new membership here\r\n        members[msg.sender].totalEarnings = 0;\r\n        members[msg.sender].directRefEarnings = 0;\r\n\r\n        //add the points to the node hereca\r\n        //get the node\r\n        SharedStructs.Node memory node = nodes[member.slotIndex];\r\n        uint256 totalPoints = node.points + packagePoints;\r\n        node.points = totalPoints;\r\n\r\n        //add the node back to the binary tree system\r\n        if (member.slotIndex != 0 && member.slotIndex != 1000000) {\r\n            //not the owner and not the node not inserted yet\r\n            nodes[member.slotIndex] = node;\r\n        }\r\n\r\n        //share to greedy bastards\r\n        shareTokenFeeToAdmin(amountToShare);\r\n        VUSDTOKEN.transferFrom(msg.sender, tokenManager, amountToContract);\r\n        //require(success, \"transfer failed\");\r\n\r\n        //transfer vnt to the greedy bastards\r\n        shareTransactionFeeOfVNTToAdmin(msg.value);\r\n    }\r\n\r\n    function withdrawEarnings() public payable {\r\n        (uint256 minimumWithdrawal, , , uint256 clickReward) = controlContract\r\n            .getTransactionDetails();\r\n        //check if the person has not collected more than their package\r\n        //Member memory member = members[msg.sender];\r\n        //check transaction tax\r\n\r\n        if (msg.value < transactionTax) {\r\n            revert();\r\n        }\r\n\r\n        //get package total Earnings\r\n        uint256 maximumEarnings;\r\n        if (members[msg.sender].membershipType == MembershipType.ELITE) {\r\n            maximumEarnings = membershipPackagesArray[0].maximumIncome;\r\n        } else if (\r\n            members[msg.sender].membershipType == MembershipType.PLATINUM\r\n        ) {\r\n            maximumEarnings = membershipPackagesArray[2].maximumIncome;\r\n        } else if (\r\n            members[msg.sender].membershipType == MembershipType.PREMIUM\r\n        ) {\r\n            maximumEarnings = membershipPackagesArray[1].maximumIncome;\r\n        }\r\n        //check if they have not withdraw more than necessary\r\n        maximumEarnings = maximumEarnings * 1 ether;\r\n        if (members[msg.sender].slotIndex != 0) {\r\n            if (members[msg.sender].totalEarnings >= maximumEarnings) {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        //prepare the withdrawal here\r\n        //bonus due to directRef\r\n        uint256 amountAvailableToWithdraw;\r\n\r\n        amountAvailableToWithdraw = members[msg.sender].directRefEarnings; //already in 18 decimals coming from the client\r\n\r\n        uint256 smbBonus = controlContract.getSmbBonus();\r\n\r\n        //bonus due to SMB\r\n        //calculateSMBBonus();\r\n        //uint256 smbPoints = smbBonusEarned[msg.sender];\r\n\r\n        //get the token worth of the points\r\n        amountAvailableToWithdraw += ((smbBonusEarned[msg.sender] * smbBonus) * 1 ether); //multiply by 18 decimals\r\n        //bonus due to daily click\r\n\r\n        uint256 pointClicked = members[msg.sender].clickRewardEarned;\r\n\r\n        //click reward comes in as ether\r\n        amountAvailableToWithdraw += (pointClicked * clickReward);\r\n        //add amount available to withdraw to extra earnings left\r\n\r\n        // require(\r\n        //     amountAvailableToWithdraw >= minimumWithdrawal,\r\n        //     \"minimum withdrawal not met\"\r\n        // );\r\n\r\n        //we are good here we can withdraw.\r\n        uint256 amountToTransfer;\r\n        //uint256 amountAfterTax = amountAvailableToWithdraw;\r\n        \r\n\r\n        if (\r\n            amountAvailableToWithdraw == 0 ||\r\n            members[msg.sender].totalEarnings == maximumEarnings\r\n        ) {\r\n            amountToTransfer = 0;\r\n        } else if (\r\n           amountAvailableToWithdraw + members[msg.sender].totalEarnings > maximumEarnings\r\n        ) {\r\n            //we need to just get the balance\r\n            uint256 balance = maximumEarnings -\r\n                members[msg.sender].totalEarnings;\r\n            if (amountAvailableToWithdraw > balance) {\r\n                amountToTransfer = balance;\r\n            } else {\r\n                amountToTransfer = amountAvailableToWithdraw;\r\n            }\r\n        } else {\r\n            amountToTransfer = amountAvailableToWithdraw;\r\n        }\r\n        \r\n          if (amountToTransfer < (minimumWithdrawal)) {\r\n             revert();\r\n        }\r\n        //require(amountToTransfer > minimumWithdrawal, \"\");\r\n\r\n        //add the money to the totalEarnings\r\n        members[msg.sender].totalEarnings =\r\n            members[msg.sender].totalEarnings +\r\n            amountToTransfer;\r\n        //set the directRef to 0\r\n        members[msg.sender].directRefEarnings = 0;\r\n        //set the dailyClick to 0\r\n        members[msg.sender].clickRewardEarned = 0;\r\n        //set the SMB to 0\r\n        smbBonusEarned[msg.sender] = 0;\r\n\r\n\r\n        uint256 finalAmount = (amountToTransfer * 90) / 100;\r\n        uint256 taxOnWithdrawal = (amountToTransfer * 10) / 100;\r\n\r\n        tokenManager.call(\r\n            abi.encodeWithSignature(\r\n                \"transfer(address,uint256)\",\r\n                msg.sender,\r\n                finalAmount\r\n            )\r\n        );\r\n\r\n        //Transfer 10% to the greedy bastards\r\n        shareTokenFeeToAdminOnWithdrawal(taxOnWithdrawal);\r\n\r\n        //transfer tax to greedy bastards\r\n        shareTransactionFeeOfVNTToAdmin(msg.value);\r\n    }\r\n\r\n    function insertSpillOverMember(\r\n        uint256 parentIndex,\r\n        uint256 points,\r\n        address memberAddress\r\n    ) public payable {\r\n        //check if the nodeToInsert exist on the spillNodeArray\r\n        SpillNode[] memory spillNode = spillNodeArray[msg.sender];\r\n        bool exist;\r\n        uint256 indexToRemove;\r\n        for (uint8 i = 0; i < spillNode.length; i++) {\r\n            if (spillNode[i].memberAddress == memberAddress) {\r\n                exist = true;\r\n                indexToRemove = i;\r\n            }\r\n        }\r\n\r\n        // if (!exist) {\r\n        //     revert();\r\n        // }\r\n\r\n        //get the member\r\n        Member memory member = members[memberAddress];\r\n        SharedStructs.Node memory parentNode = nodes[parentIndex];\r\n\r\n        if (parentNode.memberAddress != address(0)) {\r\n            uint256 childNode;\r\n            if (parentNode.leftPointer == 0) {\r\n                //add the node here\r\n                childNode = 2 * parentIndex + 1;\r\n                nodes[parentIndex].leftPointer = childNode;\r\n            } else if (parentNode.rightPointer == 0) {\r\n                childNode = 2 * parentIndex + 2;\r\n                nodes[parentIndex].rightPointer = childNode;\r\n            } else {\r\n                revert(\"in\");\r\n            }\r\n            //we can insert\r\n            //create a new Node to insert\r\n            SharedStructs.Node memory newNode;\r\n            newNode.index = childNode;\r\n            newNode.leftPointer = 0;\r\n            newNode.rightPointer = 0;\r\n            newNode.memberAddress = member.walletAddress;\r\n            newNode.points = points;\r\n\r\n            //place the new node on the nodes array\r\n            nodes[childNode] = newNode;\r\n\r\n            //add the pointer to the member\r\n            members[member.walletAddress].slotIndex = childNode;\r\n\r\n            //push the new index to the upline invites array\r\n            //members[msg.sender].invites.push(childNode);\r\n\r\n            //remove the node from the spillOverNodeArray\r\n            spillNodeArray[msg.sender][indexToRemove] = spillNodeArray[\r\n                msg.sender\r\n            ][spillNodeArray[msg.sender].length - 1];\r\n            spillNodeArray[msg.sender].pop();\r\n\r\n            //remit tax to the greedy bastards:\r\n            //transfer the VNT to the control contract first\r\n\r\n            //think of a way to structure the sharing\r\n            shareTransactionFeeOfVNTToAdmin(msg.value);\r\n        }\r\n    }\r\n\r\n    function generateSubNodeFromBinaryTree() public {\r\n        //check if the person is a member\r\n        SharedStructs.Node[1000] memory subNodes;\r\n        uint8 subNodeLength = 0;\r\n        //Member memory findMember = members[msg.sender];\r\n        uint256 slotIndex;\r\n        if (\r\n            members[msg.sender].walletAddress != address(0) &&\r\n            members[msg.sender].slotIndex != 1000000\r\n        ) {\r\n            //check if they have a slot number\r\n            slotIndex = members[msg.sender].slotIndex;\r\n            if (\r\n                (slotIndex == 0 &&\r\n                    members[msg.sender].walletAddress == ownerWallet) ||\r\n                slotIndex != 1000000\r\n            ) {\r\n                //this code will run if the slotIndex is 0 and the wallet address is the owner\r\n                //or it will also run if the slotIndex is not zero\r\n                SharedStructs.Node memory startingNode = nodes[slotIndex];\r\n                //add the node to the queue\r\n                controlContract._enqueue(startingNode); //starting point\r\n\r\n                while (controlContract.getHead() != controlContract.getTail()) {\r\n                    // Get the index of the next node in the queue\r\n                    SharedStructs.Node memory dequeueNode = controlContract\r\n                        ._dequeue();\r\n                    //add to the final array to return here\r\n                    subNodes[subNodeLength] = dequeueNode;\r\n                    //increment subNodeLength\r\n                    subNodeLength++;\r\n\r\n                    //check left pointer\r\n                    if (dequeueNode.leftPointer != 0) {\r\n                        controlContract._enqueue(\r\n                            nodes[dequeueNode.leftPointer]\r\n                        );\r\n                    }\r\n                    //check right pointer\r\n                    if (dequeueNode.rightPointer != 0) {\r\n                        controlContract._enqueue(\r\n                            nodes[dequeueNode.rightPointer]\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //remove what was there before\r\n        delete memberSubNode[msg.sender];\r\n        bool savedAlready;\r\n        for (uint256 i = 0; i < subNodes.length; i++) {\r\n            if (slotIndex == 0 && subNodes[i].index == 0 && !savedAlready) {\r\n                memberSubNode[msg.sender].push(subNodes[i]);\r\n                savedAlready = true;\r\n            } else if (subNodes[i].index != 0) {\r\n                memberSubNode[msg.sender].push(subNodes[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function retrieveSubNode()\r\n        public\r\n        view\r\n        returns (SharedStructs.Node[] memory, uint256[] memory)\r\n    {\r\n        //return the generated sub node of the user;\r\n        return (memberSubNode[msg.sender], members[msg.sender].smbNodesReceived);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n\r\n    function clickToEarn() public payable {\r\n        // (, , uint256 transactionTax, ) = controlContract\r\n        //     .getTransactionDetails();\r\n        if (\r\n            members[msg.sender].walletAddress == address(0) ||\r\n            msg.value < transactionTax\r\n        ) {\r\n            revert();\r\n        }\r\n\r\n        //require(msg.value >= transactionTax, \"insufficient tax sent\");\r\n        //Member memory member = members[msg.sender];\r\n        uint256 allowedDailyClicks;\r\n        if (members[msg.sender].membershipType == MembershipType.ELITE) {\r\n            allowedDailyClicks = membershipPackagesArray[0].dailyClicks;\r\n        } else if (\r\n            members[msg.sender].membershipType == MembershipType.PLATINUM\r\n        ) {\r\n            allowedDailyClicks = membershipPackagesArray[2].dailyClicks;\r\n        } else if (\r\n            members[msg.sender].membershipType == MembershipType.PREMIUM\r\n        ) {\r\n            allowedDailyClicks = membershipPackagesArray[1].dailyClicks;\r\n        }\r\n\r\n        //uint256 fs = member.firstClickToday + (1 days);\r\n\r\n        if (block.timestamp < members[msg.sender].firstClickToday + (1 days)) {\r\n            //we can still click\r\n            if (members[msg.sender].clickCount >= allowedDailyClicks) {\r\n                revert();\r\n            }\r\n            //add the click to the\r\n            members[msg.sender].clickRewardEarned += 1;\r\n            members[msg.sender].clickCount += 1;\r\n        } else {\r\n            //we need to reset the click here\r\n            members[msg.sender].firstClickToday = block.timestamp;\r\n            members[msg.sender].clickRewardEarned += 1;\r\n            members[msg.sender].clickCount = 1;\r\n        }\r\n\r\n        //share tax to greedy bastards\r\n        shareTransactionFeeOfVNTToAdmin(msg.value);\r\n    }\r\n\r\n    function shareTransactionFeeOfVNTToAdmin(uint256 amount) public {\r\n        //20% and 80%\r\n        //require(ownerWallet != address(0), \"owner wallet not set\");\r\n        //require(adminWallet.length == 4, \"set admin wallet\");\r\n        adminVNTPurse[ownerWallet] += (amount * 20) / 100;\r\n\r\n        for (uint256 i = 0; i < adminWallet.length; i++) {\r\n            adminVNTPurse[adminWallet[i]] += (amount * 20) / 100;\r\n        }\r\n    }\r\n\r\n    function withdrawTokenFromContract() public {\r\n        uint256 assetBalance = adminVNTPurse[msg.sender];\r\n        if (assetBalance > 0) {\r\n            payable(msg.sender).call{value: assetBalance}(\"\");\r\n        }\r\n    }\r\n\r\n    function changeTransactionTax(uint256 tranTax) public onlyOwner {\r\n        //dividing transaction tax by 1000\r\n        if (tranTax > 0) {\r\n            transactionTax = (tranTax * 1 ether) / 1000;\r\n        }\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == ownerWallet);\r\n        _;\r\n    }\r\n\r\n    function shareTokenFeeToAdmin(uint256 amount) public {\r\n        //20% and 80%\r\n        VUSDTOKEN.transferFrom(msg.sender, ownerWallet, (amount * 20) / 100);\r\n\r\n        for (uint256 i = 0; i < adminWallet.length; i++) {\r\n            VUSDTOKEN.transferFrom(\r\n                msg.sender,\r\n                adminWallet[i],\r\n                (amount * 20) / 100\r\n            );\r\n        }\r\n    }\r\n\r\n    function shareTokenFeeToAdminOnWithdrawal(uint256 amount) public {\r\n        //20% and 80%\r\n        tokenManager.call(\r\n            abi.encodeWithSignature(\r\n                \"transfer(address,uint256)\",\r\n                ownerWallet,\r\n                (amount * 20) / 100\r\n            )\r\n        );\r\n\r\n        for (uint256 i = 0; i < adminWallet.length; i++) {\r\n            //VUSDTOKEN.transfer(adminWallet[i], (amount * 20) / 100);\r\n            tokenManager.call(\r\n                abi.encodeWithSignature(\r\n                    \"transfer(address,uint256)\",\r\n                    adminWallet[i],\r\n                    (amount * 20) / 100\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    // function getNodeByIndex(uint256 index)\r\n    //     public\r\n    //     view\r\n    //     returns (\r\n    //         address,\r\n    //         uint256,\r\n    //         uint256,\r\n    //         uint256,\r\n    //         uint256\r\n    //     )\r\n    // {\r\n    //     SharedStructs.Node memory node = nodes[index];\r\n    //     return (\r\n    //         node.memberAddress,\r\n    //         node.index,\r\n    //         node.leftPointer,\r\n    //         node.rightPointer,\r\n    //         node.points\r\n    //     );\r\n    // }\r\n\r\n    function updateSMBBalance(\r\n        uint256 smb,\r\n        //SharedStructs.Node[] memory nodesToUpdate\r\n        uint256[] memory contributingNodes\r\n        \r\n    ) public {\r\n        members[msg.sender].smbNodesReceived = contributingNodes;\r\n\r\n\r\n        // for (uint256 i = 0; i < nodesToUpdate.length; i++) {\r\n        //     SharedStructs.Node memory currentNode = nodesToUpdate[i];\r\n        //     nodes[currentNode.index].points = currentNode.points;\r\n        // }\r\n         if (smb > 0) {\r\n             smbBonusEarned[msg.sender] = smbBonusEarned[msg.sender] + smb;\r\n         }\r\n    }\r\n\r\n    function getMemberDetails()\r\n        public\r\n        view\r\n        returns (\r\n            SpillNode[] memory,\r\n            address,\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint8\r\n        )\r\n    {\r\n        return (\r\n            spillNodeArray[msg.sender],\r\n            members[msg.sender].walletAddress,\r\n            members[msg.sender].upline,\r\n            members[msg.sender].slotIndex,\r\n            members[msg.sender].directRefEarnings,\r\n            members[msg.sender].clickRewardEarned,\r\n            members[msg.sender].totalEarnings,\r\n            members[msg.sender].firstClickToday,\r\n            members[msg.sender].clickCount\r\n        );\r\n    }\r\n\r\n    // function withdrawLeftOverFunds() public onlyOwner {\r\n    //     //loop through the VNT purse\r\n    //     uint256 sumTotal;\r\n\r\n    //     for (uint8 i = 0; i < adminWallet.length; i++) {\r\n    //         sumTotal += adminVNTPurse[adminWallet[i]];\r\n    //     }\r\n\r\n    //     sumTotal += adminVNTPurse[ownerWallet];\r\n    //     uint256 totalBal = address(this).balance;\r\n    //     uint256 toWithdraw = totalBal - sumTotal;\r\n    //     if (toWithdraw > 0) {\r\n    //         //withdraw balance\r\n    //         payable(msg.sender).call{value: toWithdraw}(\"\");\r\n    //         //require(success, \"f\");\r\n    //     }\r\n    // }\r\n\r\n    //Admin Function Starts Here //\r\n\r\n    //Admin Function Ends Here //\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/ControlContract.sol": {
      "content": "//SPDX-License-Identifier:MIT\r\npragma solidity ^0.8.15;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"./Lib.sol\";\r\n\r\nenum MembershipType {\r\n    ELITE,\r\n    PREMIUM,\r\n    PLATINUM\r\n}\r\n\r\n//vusd contract address : 0x8694A1A789133c94aA3c95B80c852583628A93b6\r\n\r\ncontract ControlContract is Ownable, ReentrancyGuard {\r\n    //storage\r\n\r\n    using SharedStructs for *;\r\n\r\n    // Define the head and tail indices as public storage variables\r\n    uint256 public head;\r\n    uint256 public tail;\r\n\r\n    address private tokenManager;\r\n\r\n    //SIMPLE QUEUE VARIABLE\r\n    SharedStructs.Node[] public Nodequeue;\r\n\r\n    SharedStructs.Node public nodeStruct;\r\n\r\n    //where to place the Member in the tree\r\n    uint256 public advertCost;\r\n\r\n    uint256 public transactionTax = 1;\r\n\r\n    //click reward in cents $1 token VUSD\r\n    uint256 public clickReward = 1;\r\n\r\n    address public ownerWallet; //wallet of owner\r\n\r\n    uint256 public minimumWithdrawal = 50 * 1 ether;\r\n    uint256 public smbBonus = 2;\r\n\r\n    //payment wallet\r\n    //address[5] public advertWalletPayment;\r\n    address[] public adminWallet;\r\n\r\n    //0=> owner wallet %\r\n    //1=> admin wallet %\r\n    uint8[3] public advertFeePercentage;\r\n\r\n    uint256[3] public memberEntryPercentage;\r\n\r\n    //the array to hold the price of the membership packages of elite, premium and platinum\r\n    uint256[3] public membershipPackagePriceArray;\r\n\r\n    address private vusdContractAddress;\r\n    IERC20 private VUSDTOKEN;\r\n\r\n    //0=> elite plan : 1=> premium : 2=> platinum\r\n    SharedStructs.MembershipPackage[] public membershipPackagesArray;\r\n\r\n    //mappings\r\n    //mapping(address => Advertiser) public advertisers;\r\n    Advertiser[] public advertisers;\r\n    mapping(address => SpillNode[]) spillNodeArray; //the array that contains all spill nodes;\r\n\r\n    //withdrawal history\r\n    mapping(address => History[]) public withdrawalHistory;\r\n\r\n    //admin VNT purse in the main contract\r\n    mapping(address => uint256) public adminVNTPurse;\r\n\r\n    //struct\r\n\r\n    struct History {\r\n        uint256 time;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct Advertiser {\r\n        address owner;\r\n        string message;\r\n        string[] links;\r\n        bool active;\r\n        uint256 dateSubscribed;\r\n    }\r\n\r\n    //the membership package\r\n\r\n    struct SpillNode {\r\n        address memberAddress;\r\n        uint256 points;\r\n    }\r\n\r\n    constructor(\r\n        address owner,\r\n        address tokenAddress,\r\n        address[] memory wallets,\r\n        address tokenManagerAddress\r\n    ) Ownable() {\r\n        ownerWallet = owner;\r\n        tokenManager = tokenManagerAddress;\r\n        VUSDTOKEN = IERC20(tokenAddress);\r\n        //set admin adminWallet\r\n        for (uint8 i = 0; i < wallets.length; i++) {\r\n            adminWallet.push(wallets[i]);\r\n        }\r\n    }\r\n\r\n    function buyAdvertiserPlan(string memory message, string[] memory links)\r\n        public\r\n    {\r\n        //check if all parameters are set\r\n        require(advertCost > 0, \"Advert cost not set\");\r\n        //check token balance;\r\n        require(\r\n            checkTokenBalance(msg.sender) > advertCost,\r\n            \"Transfer balancee small\"\r\n        );\r\n\r\n        //save the advitiser\r\n\r\n        Advertiser memory newAdvertiser;\r\n\r\n        newAdvertiser.active = true;\r\n        newAdvertiser.dateSubscribed = block.timestamp;\r\n        newAdvertiser.links = links;\r\n        newAdvertiser.message = message;\r\n        newAdvertiser.owner = msg.sender;\r\n        advertisers.push(newAdvertiser);\r\n\r\n        //perform the mathematics of sharing\r\n        uint256 amountToShare = (advertCost * 10) / 100;\r\n\r\n        //2% of it goes to owner wallet (1 address)\r\n        //-8% goes to 4 wallets with 2% each (4 address)\r\n        //90% goes to smartcontract address (1 address\r\n        shareTokenFeeToAdmin(amountToShare);\r\n        //transfer the 90% to the contract\r\n        uint256 amountToContract = (advertCost * 90) / 100;\r\n        bool success = VUSDTOKEN.transferFrom(\r\n            msg.sender,\r\n            tokenManager,\r\n            amountToContract\r\n        );\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    function shareTokenFeeToAdmin(uint256 amount) public {\r\n        //20% and 80%\r\n        require(ownerWallet != address(0), \"owner wallet not set\");\r\n        require(adminWallet.length == 4, \"set admin wallet\");\r\n        bool success = VUSDTOKEN.transferFrom(\r\n            msg.sender,\r\n            ownerWallet,\r\n            (amount * 20) / 100\r\n        );\r\n        require(success);\r\n        for (uint256 i = 0; i < adminWallet.length; i++) {\r\n            bool success2 = VUSDTOKEN.transferFrom(\r\n                msg.sender,\r\n                adminWallet[i],\r\n                (amount * 20) / 100\r\n            );\r\n            require(success2);\r\n        }\r\n    }\r\n\r\n    function getAdvertFeePercentage() public view returns (uint8[3] memory) {\r\n        return advertFeePercentage;\r\n    }\r\n\r\n    function getMemberEntryPercentage()\r\n        public\r\n        view\r\n        returns (uint256[3] memory)\r\n    {\r\n        return memberEntryPercentage;\r\n    }\r\n\r\n    function getMembershipPackagePriceArray()\r\n        public\r\n        view\r\n        returns (uint256[3] memory)\r\n    {\r\n        return membershipPackagePriceArray;\r\n    }\r\n\r\n    function getMembershipPackagesArray()\r\n        public\r\n        view\r\n        returns (SharedStructs.MembershipPackage[] memory)\r\n    {\r\n        return membershipPackagesArray;\r\n    }\r\n\r\n    function getOwnerWallet() public view returns (address) {\r\n        return ownerWallet;\r\n    }\r\n\r\n    function getSmbBonus() public view returns (uint256) {\r\n        return smbBonus;\r\n    }\r\n\r\n    function getTransactionDetails()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        //minimumWithdrawal\r\n        //advertCost\r\n        //transactionTax\r\n        //clickReward\r\n        return (minimumWithdrawal, advertCost, transactionTax, clickReward);\r\n    }\r\n\r\n    function checkTokenBalance(address wallet) public view returns (uint256) {\r\n        return VUSDTOKEN.balanceOf(wallet);\r\n    }\r\n\r\n    //Admin Function Starts Here //\r\n    function configureSMBBonusAndMinimumWithdrawal(\r\n        uint256 minWithdrawal,\r\n        uint256 smbBonusAllocation\r\n    ) public onlyOwner {\r\n        if (minimumWithdrawal > 0) {\r\n            minimumWithdrawal = minWithdrawal * 1 ether;\r\n        }\r\n        if (smbBonusAllocation > 0) {\r\n            smbBonus = smbBonusAllocation;\r\n        }\r\n    }\r\n\r\n    function setAdminDetails(uint256 adCost, uint256 rewardForClicking)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (adCost > 0) {\r\n            advertCost = adCost * 1 ether;\r\n        }\r\n\r\n        //divide what comes in by 1000\r\n        if (rewardForClicking > 0) {\r\n            clickReward = (rewardForClicking * 1 ether) / 1000;\r\n            //clickReward = rewardForClicking;\r\n        }\r\n    }\r\n\r\n    function setAdminWallet(address[] memory wallets) public onlyOwner {\r\n        require(wallets.length == 4, \"the wallet length should be 4\");\r\n        for (uint8 i = 0; i < wallets.length; i++) {\r\n            adminWallet[i] = wallets[i];\r\n        }\r\n    }\r\n\r\n    // function setTransactionTax(uint256 amount) public onlyOwner {\r\n    //     transactionTax = amount;\r\n    // }\r\n\r\n    function setOwnerWallet(address wallet) public onlyOwner {\r\n        ownerWallet = wallet;\r\n    }\r\n\r\n    // function setAdvertCost(uint256 cost) public onlyOwner {\r\n    //     advertCost = cost;\r\n    // }\r\n\r\n    // function setClickReward(uint256 cost) public onlyOwner {\r\n    //     clickReward = cost;\r\n    // }\r\n\r\n    function setAdvertMemberFeePercentage(\r\n        uint8[2] memory advertFeeArray,\r\n        uint8[2] memory memberFeeArray\r\n    ) public onlyOwner {\r\n        if (advertFeeArray.length > 0) {\r\n            for (uint256 i = 0; i < advertFeeArray.length; i++) {\r\n                advertFeePercentage[i] = advertFeeArray[i];\r\n            }\r\n        }\r\n\r\n        if (memberFeeArray.length > 0) {\r\n            for (uint256 i = 0; i < memberFeeArray.length; i++) {\r\n                memberEntryPercentage[i] = memberFeeArray[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function setMembershipPackage(\r\n        uint256 index,\r\n        uint256 dailyClicks,\r\n        uint256 packagePoints,\r\n        uint256 maximumIncome\r\n    ) public onlyOwner {\r\n        require(\r\n            index <= membershipPackagesArray.length - 1,\r\n            \"invalid array length\"\r\n        );\r\n        SharedStructs.MembershipPackage memory editMembershipPackage;\r\n        editMembershipPackage.dailyClicks = dailyClicks;\r\n        editMembershipPackage.packagePoints = packagePoints;\r\n        editMembershipPackage.maximumIncome = maximumIncome;\r\n        membershipPackagesArray[index] = editMembershipPackage;\r\n    }\r\n\r\n    function advertClickIsWithin24Hours(uint256 firstClick)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        //check if firstClick is is within 24hrs\r\n        uint256 fs = firstClick + (1 days);\r\n        if (block.timestamp < fs) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function shareTransactionFeeOfVNTToAdmin(uint256 amount) public {\r\n        //20% and 80%\r\n        require(ownerWallet != address(0), \"owner wallet not set\");\r\n        require(adminWallet.length == 4, \"set admin wallet\");\r\n        adminVNTPurse[ownerWallet] += (amount * 20) / 100;\r\n\r\n        for (uint256 i = 0; i < adminWallet.length; i++) {\r\n            adminVNTPurse[adminWallet[i]] += (amount * 20) / 100;\r\n        }\r\n    }\r\n\r\n    function shareWithdrawalTaxFeeToAdmin(uint256 amount) public {\r\n        //20% and 80%\r\n        require(ownerWallet != address(0), \"owner wallet not set\");\r\n        require(adminWallet.length == 4, \"set admin wallet\");\r\n        (bool success, ) = tokenManager.call(\r\n            abi.encodeWithSignature(\r\n                \"transfer(address,uint256)\",\r\n                ownerWallet,\r\n                (amount * 20) / 100\r\n            )\r\n        );\r\n\r\n        require(success);\r\n        for (uint256 i = 0; i < adminWallet.length; i++) {\r\n            (bool success2, ) = tokenManager.call(\r\n                abi.encodeWithSignature(\r\n                    \"transfer(address,uint256)\",\r\n                    adminWallet[i],\r\n                    (amount * 20) / 100\r\n                )\r\n            );\r\n            require(success2);\r\n        }\r\n    }\r\n\r\n    function _dequeue() public returns (SharedStructs.Node memory) {\r\n        // If the queue is empty, throw an exception\r\n        require(head != tail, \"Error: Queue is empty\");\r\n\r\n        // Get the value of the front element\r\n        SharedStructs.Node memory value = Nodequeue[head];\r\n\r\n        // Update the head index\r\n        head = (head + 1);\r\n\r\n        // Return the value of the removed node\r\n        return value;\r\n    }\r\n\r\n    // Define a function to add a new value to the end of the queue\r\n    function _enqueue(SharedStructs.Node memory value) public {\r\n        // Add the new value to the end of the queue\r\n        Nodequeue.push(value);\r\n        // Update the tail index\r\n        tail = (tail + 1);\r\n    }\r\n\r\n    function getHead() public view returns (uint256) {\r\n        return head;\r\n    }\r\n\r\n    function getTail() public view returns (uint256) {\r\n        return tail;\r\n    }\r\n\r\n    function getTokenBalance(address account) public view returns (uint256) {\r\n        return VUSDTOKEN.balanceOf(account);\r\n    }\r\n\r\n    function getAllAdverts() public view returns (Advertiser[] memory) {\r\n        return advertisers;\r\n    }\r\n\r\n    //Admin Function Ends Here //\r\n}\r\n"
    },
    "contracts/Lib.sol": {
      "content": "//SPDX-License-Identifier:MIT\r\npragma solidity ^0.8.15;\r\n\r\n\r\nlibrary SharedStructs {\r\n     struct Node {\r\n        address memberAddress;\r\n        uint256 index; //the index occupied in the array\r\n        uint256 leftPointer;\r\n        uint256 rightPointer;\r\n        uint256 points; //point of the plan\r\n    }\r\n     struct MembershipPackage {\r\n        uint256 dailyClicks;\r\n        uint256 packagePoints;\r\n        uint256 maximumIncome;\r\n    }\r\n    \r\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}