// //SPDX-License-Identifier:MIT
// pragma solidity ^0.8.0;

// import "@openzeppelin/contracts/access/Ownable.sol";
// import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

// //enum storage
// enum MembershipType {
//     ELITE,
//     PREMIUM,
//     PLATINUM
// }

// //vusd contract address : 0x8694A1A789133c94aA3c95B80c852583628A93b6

// contract PayToClickContract is Ownable, ReentrancyGuard {
//     //storage

//     // Define the head and tail indices as public storage variables
//     uint256 public head;
//     uint256 public tail;

//     //where to place the Member in the tree
//     uint256 private currentIndex;
//     uint256 public advertCost;

//     uint256 public transactionTax = 1;

//     //click reward in cents $1 token VUSD
//     uint256 public clickReward = 1;

//     address public ownerWallet; //wallet of owner

//     uint256 public minimumWithdrawal = 1;
//     uint256 public smbBonus = 2;

//     //payment wallet
//     //address[5] public advertWalletPayment;
//     address[4] public adminWallet;

//     //0=> owner wallet %
//     //1=> admin wallet %
//     uint8[3] public advertFeePercentage;

//     uint256[3] public memberEntryPercentage;

//     //the array to hold the price of the membership packages of elite, premium and platinum
//     uint256[3] public membershipPackagePriceArray;

//     address private vusdContractAddress;
//     IERC20 private VUSDTOKEN;

//     //array of nodes
//     Node[] private nodes;
//     //0=> elite plan : 1=> premium : 2=> platinum
//     MembershipPackage[] public membershipPackagesArray;

//     //SIMPLE QUEUE VARIABLE
//     Node[] public Nodequeue;

//     //mappings
//     mapping(address => Member) members;
//     mapping(address => Advertiser) advertisers;
//     mapping(address => SpillNode[]) spillNodeArray; //the array that contains all spill nodes;

//     mapping(address => Node[]) public memberSubNode;
//     mapping(address => uint256) public smbBonusEarned;

//     //withdrawal history
//     mapping(address => History[]) public withdrawalHistory;

//     //struct

//     struct History {
//         uint256 time;
//         uint256 amount;
//     }

//     struct Advertiser {
//         address owner;
//         string message;
//         string[] links;
//         bool active;
//         uint256 dateSubscribed;
//     }

//     struct Node {
//         address memberAddress;
//         uint256 index; //the index occupied in the array
//         uint256 leftPointer;
//         uint256 rightPointer;
//         uint256 points; //point of the plan
//     }

//     struct Member {
//         address walletAddress;
//         address upline; //the referral address
//         uint256 slotIndex; //the index in the array
//         uint256 uplineIndex; //the index of the upline
//         //direct referral bonus earned
//         uint256 directRefEarnings; //10% of package size
//         uint256 clickRewardEarned; //total number of clicks
//         uint256 moneyCalculatedLeft; //money that is left after cal withdrawal
//         uint256 totalEarnings; //total amount they have earned
//         uint256 firstClickToday; //the firsttime the advert was clicked
//         //array of invites that is the node positions
//         uint256[] invites;
//         MembershipType membershipType;
//         bool status; //if the member is active or not
//         uint8 clickCount; //how many times they have clicked in 24 hours
//     }

//     //the membership package
//     struct MembershipPackage {
//         uint256 dailyClicks;
//         uint256 packagePoints;
//         uint256 maximumIncome;
//     }

//     struct SpillNode {
//         address memberAddress;
//         uint256 points;
//     }

//     constructor(address owner, address tokenAddress) Ownable() {
//         //set all default packages value;
//         //set all default membership plan
//         for (uint256 i = 0; i < 3; i++) {
//             if (i == 0) {
//                 MembershipPackage memory newPackage;
//                 newPackage.dailyClicks = 10;
//                 newPackage.packagePoints = 1;
//                 newPackage.maximumIncome = 100;
//                 membershipPackagesArray[0] = newPackage;
//             }
//             if (i == 1) {
//                 MembershipPackage memory newPackage;
//                 newPackage.dailyClicks = 20;
//                 newPackage.packagePoints = 5;
//                 newPackage.maximumIncome = 500;
//                 membershipPackagesArray[0] = newPackage;
//             }

//             if (i == 2) {
//                 MembershipPackage memory newPackage;
//                 newPackage.dailyClicks = 30;
//                 newPackage.packagePoints = 25;
//                 newPackage.maximumIncome = 2500;
//                 membershipPackagesArray[0] = newPackage;
//             }
//         }
//         _setInitialPyramid(owner);
//         VUSDTOKEN = IERC20(tokenAddress);
//     }

//     function buyAdvertiserPlan(string memory message, string[] memory links)
//         public
//     {
//         //check if all parameters are set
//         require(advertCost > 0, "AF");
//         //check token balance;
//         require(
//             checkTokenBalance(msg.sender) > advertCost,
//             "Transfer balancee small"
//         );

//         //save the advitiser

//         Advertiser memory newAdvertiser;

//         newAdvertiser.active = true;
//         newAdvertiser.dateSubscribed = block.timestamp;
//         newAdvertiser.links = links;
//         newAdvertiser.message = message;
//         newAdvertiser.owner = msg.sender;
//         advertisers[msg.sender] = newAdvertiser;

//         //perform the mathematics of sharing
//         uint256 amountToShare = (advertCost * 10) / 100;

//         //2% of it goes to owner wallet (1 address)
//         //-8% goes to 4 wallets with 2% each (4 address)
//         //90% goes to smartcontract address (1 address
//         _shareTokenFeeToAdmin(amountToShare);
//         //transfer the 90% to the contract
//         uint256 amountToContract = (advertCost * 90) / 100;
//         bool success = VUSDTOKEN.transferFrom(
//             msg.sender,
//             address(this),
//             amountToContract
//         );
//         require(success, "T-F");
//     }

//     function buyMembershipPlan(uint256 planIndex, address referral)
//         public
//         nonReentrant
//     {
//         //check if the referral is valid if not valid referral is the owner with index 0;
//         if (referral == address(0)) {
//             referral = nodes[0].memberAddress;
//         }
//         //check if the person has the token to be able to buy the plan;
//         require(
//             members[referral].walletAddress != address(0),
//             "referral not a member"
//         );
//         //check if the member already exist and also check if not active
//         require(
//             members[msg.sender].walletAddress != address(0),
//             "member does not exist"
//         );

//         require(planIndex > 2, "invalid membership index passed");

//         //
//         require(
//             membershipPackagePriceArray[0] == 0,
//             "membership price not set"
//         );
//         uint256 planPrice = membershipPackagePriceArray[planIndex];
//         //check if they have tokens
//         require(
//             VUSDTOKEN.balanceOf(msg.sender) >= planPrice,
//             "insufficent token to buy plan"
//         );
//         uint256 allowancePermitted = VUSDTOKEN.allowance(
//             msg.sender,
//             address(this)
//         );
//         require(allowancePermitted < planPrice, "insufficient allowance set");

//         uint256 planPoints = membershipPackagesArray[planIndex].packagePoints;
//         //insert member into nodes
//         (uint256 insertIndex, bool canInsert) = _insertMemberIntoNode(
//             referral,
//             planPoints
//         );

//         //create a new Member
//         createNewMember(referral, insertIndex, planIndex);

//         uint256 amountToShare = (planPrice * 10) / 100;
//         uint256 amountToContract = (planPrice * 80) / 100;

//         //10% bonus
//         uint256 directRefBonus = (planPrice * 10) / 100;
//         //add to the direct ref bonus
//         members[referral].directRefEarnings =
//             members[referral].directRefEarnings +
//             directRefBonus;
//         //add the index to the
//         if (canInsert) {
//             //you only add the confirm node to the invites
//             members[referral].invites.push(insertIndex);
//         }

//         _shareTokenFeeToAdmin(amountToShare);
//         bool success = VUSDTOKEN.transferFrom(
//             msg.sender,
//             address(this),
//             amountToContract
//         );
//         require(success, "transfer failed");
//     }

//     function _insertMemberIntoNode(address referral, uint256 points)
//         private
//         returns (uint256 index, bool canInsert)
//     {
//         //get the referral slotNumber
//         uint256 referralSlot = members[referral].slotIndex;
//         //get the referral node and see if the children position is filled;
//         Node memory referralNode = nodes[referralSlot];
//         if (referralNode.memberAddress != address(0)) {
//             //we have a node present.
//             //check if the leftchild is empty
//             if (referralNode.leftPointer == 0) {
//                 //we can add the new Node here
//                 uint256 newLeftIndex = referralSlot * 2 + 1;
//                 Node memory newNode;
//                 newNode.index = newLeftIndex;
//                 newNode.leftPointer = 0;
//                 newNode.rightPointer = 0;
//                 newNode.memberAddress = msg.sender;
//                 newNode.points = points;
//                 nodes[newLeftIndex] = newNode;
//                 //update the parent nodes reference here
//                 nodes[referralSlot].leftPointer = newLeftIndex;
//                 //increment the currentIndex
//                 currentIndex++;
//                 return (newLeftIndex, true);
//                 //return
//             } else if (referralNode.rightPointer == 0) {
//                 //we can add it here
//                 uint256 newRightIndex = referralSlot * 2 + 2;
//                 Node memory newNode;
//                 newNode.index = newRightIndex;
//                 newNode.leftPointer = 0;
//                 newNode.rightPointer = 0;
//                 newNode.memberAddress = msg.sender;
//                 newNode.points = points;
//                 nodes[newRightIndex] = newNode;
//                 //update the parent nodes reference here
//                 nodes[referralSlot].rightPointer = newRightIndex;
//                 //increment the currentIndex
//                 currentIndex++;
//                 return (newRightIndex, true);
//             } else {
//                 //nothing works add it to spillNode spillNodeArray
//                 SpillNode memory spillNode;
//                 spillNode.memberAddress = msg.sender;
//                 spillNode.points = points;
//                 //add the spillNode to the array
//                 spillNodeArray[referral].push(spillNode);
//                 return (0, false);
//             }
//         }
//     }

//     function createNewMember(
//         address referral,
//         uint256 slotIndex,
//         uint256 planIndex
//     ) private {
//         Member memory newMember;
//         newMember.upline = referral;
//         newMember.slotIndex = slotIndex;
//         uint256 referralSlot = members[referral].slotIndex;
//         newMember.uplineIndex = referralSlot;
//         newMember.directRefEarnings = 0;
//         newMember.walletAddress = msg.sender;
//         newMember.clickRewardEarned = 0;
//         newMember.firstClickToday = 0;
//         newMember.invites = new uint256[](0);
//         newMember.totalEarnings = 0;
//         newMember.moneyCalculatedLeft = 0;
//         MembershipType memberType;
//         if (planIndex == 0) {
//             memberType = MembershipType.ELITE;
//         } else if (planIndex == 1) {
//             memberType = MembershipType.PREMIUM;
//         } else if (planIndex == 2) {
//             memberType = MembershipType.PLATINUM;
//         }
//         newMember.membershipType = memberType;
//         newMember.status = true;
//         newMember.clickCount = 0;

//         members[msg.sender] = newMember;
//     }

//     function renewSubScription() public payable {
//         require(
//             members[msg.sender].walletAddress != address(0),
//             "you not a member buy a membership"
//         );
//         require(msg.value >= transactionTax, "insufficient tax sent");

//         Member memory member = members[msg.sender];
//         uint256 maximumEarnings;
//         uint256 planPrice;
//         uint256 packagePoints;
//         if (member.membershipType == MembershipType.ELITE) {
//             maximumEarnings = membershipPackagesArray[0].maximumIncome;
//             planPrice = membershipPackagePriceArray[0];
//             packagePoints = membershipPackagesArray[0].packagePoints;
//         } else if (member.membershipType == MembershipType.PLATINUM) {
//             maximumEarnings = membershipPackagesArray[2].maximumIncome;
//             planPrice = membershipPackagePriceArray[2];
//             packagePoints = membershipPackagesArray[2].packagePoints;
//         } else if (member.membershipType == MembershipType.PREMIUM) {
//             maximumEarnings = membershipPackagesArray[1].maximumIncome;
//             planPrice = membershipPackagePriceArray[1];
//             packagePoints = membershipPackagesArray[1].packagePoints;
//         }

//         require(
//             member.totalEarnings >= maximumEarnings,
//             "your membership still active"
//         );

//         //check if they have tokens
//         require(
//             VUSDTOKEN.balanceOf(msg.sender) >= planPrice,
//             "insufficent token to buy plan"
//         );

//         uint256 allowancePermitted = VUSDTOKEN.allowance(
//             msg.sender,
//             address(this)
//         );
//         require(allowancePermitted < planPrice, "insufficient allowance set");

//         uint256 amountToShare = (planPrice * 10) / 100;
//         uint256 amountToContract = (planPrice * 90) / 100;

//         //10% bonus
//         uint256 directRefBonus = (planPrice * 10) / 100;
//         //add to the direct ref bonus
//         members[member.upline].directRefEarnings =
//             members[member.upline].directRefEarnings +
//             directRefBonus;

//         //set the new membership here
//         members[msg.sender].totalEarnings = 0;

//         //add the points to the node here
//         //get the node
//         Node memory node = nodes[member.slotIndex];
//         uint256 totalPoints = node.points + packagePoints;
//         node.points = totalPoints;

//         //add the node back to the binary tree system
//         nodes[member.slotIndex] = node;

//         //share to greedy bastards
//         _shareTokenFeeToAdmin(amountToShare);
//         bool success = VUSDTOKEN.transferFrom(
//             msg.sender,
//             address(this),
//             amountToContract
//         );
//         require(success, "transfer failed");

//         //transfer vnt to the greedy bastards
//     }

//     function withdrawEarnings(uint256 amountToWithdraw)
//         public
//         payable
//         nonReentrant
//     {
//         //check if the person has not collected more than their package
//         Member memory member = members[msg.sender];
//         //check transaction tax
//         require(msg.value >= transactionTax, "insufficient tax sent");
//         //get package total Earnings
//         uint256 maximumEarnings;
//         if (member.membershipType == MembershipType.ELITE) {
//             maximumEarnings = membershipPackagesArray[0].maximumIncome;
//         } else if (member.membershipType == MembershipType.PLATINUM) {
//             maximumEarnings = membershipPackagesArray[2].maximumIncome;
//         } else if (member.membershipType == MembershipType.PREMIUM) {
//             maximumEarnings = membershipPackagesArray[1].maximumIncome;
//         }
//         //check if they have not withdraw more than necessary
//         if (member.slotIndex != 0) {
//             //only the other members is affected by this require
//             require(
//                 member.totalEarnings >= maximumEarnings,
//                 "you have collected the maximum amount. Renew your subscription"
//             );
//         }

//         //prepare the withdrawal here
//         //bonus due to directRef
//         uint256 amountAvailableToWithdraw;

//         amountAvailableToWithdraw += member.directRefEarnings; //already in 18 decimals coming from the client

//         //bonus due to SMB
//         calculateSMBBonus();
//         uint256 smbPoints = smbBonusEarned[msg.sender];

//         //get the token worth of the points
//         amountAvailableToWithdraw += smbPoints * smbBonus * 1 ether; //multiply by 18 decimals

//         //bonus due to daily click

//         uint256 pointClicked = member.clickRewardEarned;

//         amountAvailableToWithdraw += pointClicked * clickReward * 1 ether;

//         //add amount available to withdraw to extra earnings left

//         uint256 totalAmount = member.moneyCalculatedLeft +
//             amountAvailableToWithdraw;

//         if (totalAmount <= amountToWithdraw) {
//             //we are good here we can withdraw.
//             uint256 amountToTransfer = (amountToWithdraw * 90) / 100;
//             uint256 taxOnWithdrawal = (amountToWithdraw * 10) / 100;
//             //check if contract has that amount
//             require(
//                 VUSDTOKEN.balanceOf(address(this)) >= amountToWithdraw,
//                 "no liquidity"
//             );

//             //add the money to the totalEarnings
//             member.totalEarnings += amountToWithdraw;
//             //set the directRef to 0
//             member.directRefEarnings = 0;
//             //set the dailyClick to 0
//             member.clickCount = 0;
//             //set the SMB to 0
//             smbBonusEarned[msg.sender] = 0;
//             //minus and keep the balane in the left over balance

//             //save the history of the withdrawal
//             History memory newHistory;
//             newHistory.time = block.timestamp;
//             newHistory.amount = amountToTransfer;
//             withdrawalHistory[msg.sender].push(newHistory);

//             uint256 balance = amountToWithdraw - totalAmount;

//             member.moneyCalculatedLeft = balance;

//             //TO DO transfer 90% to the user wallet
//             bool success = VUSDTOKEN.transfer(msg.sender, amountToTransfer);
//             require(success, "transfer failed");
//             //Transfer 10% to the greedy bastards
//             _shareWithdrawalTaxFeeToAdmin(taxOnWithdrawal);

//             //transfer tax to greedy bastards
//             shareTransactionFeeOfVNTToAdmin(msg.value);
//         } else {
//             require(1 == 2, "your balance is not up to the inputed amount");
//         }
//     }

//     function insertSpillOverMember(
//         uint256 indexToUse,
//         SpillNode memory nodeToInsert
//     ) public payable {
//         //check if the nodeToInsert exist on the spillNodeArray
//         SpillNode[] memory spillNode = spillNodeArray[msg.sender];
//         bool exist;
//         uint256 indexToRemove;
//         for (uint8 i = 0; i < spillNode.length; i++) {
//             if (spillNode[i].memberAddress == nodeToInsert.memberAddress) {
//                 exist = true;
//                 indexToRemove = i;
//             }
//         }

//         if (!exist) {
//             require(1 == 2, "the member does not exist on the spill node");
//         }

//         //get the member
//         Member memory member = members[nodeToInsert.memberAddress];
//         require(member.walletAddress != address(0), "invalid mmember");
//         require(
//             members[msg.sender].walletAddress != address(0),
//             "invalid sponsor"
//         );

//         require(
//             msg.value >= transactionTax,
//             "you need to send more transaction tax"
//         );

//         //find if we can insert the node at that spot
//         Node memory getNode = nodes[indexToUse];

//         if (getNode.memberAddress != address(0)) {
//             //we can insert
//             //create a new Node to insert
//             Node memory newNode;
//             newNode.index = indexToUse;
//             newNode.leftPointer = 0;
//             newNode.rightPointer = 0;
//             newNode.memberAddress = member.walletAddress;
//             newNode.points = nodeToInsert.points;

//             //place the new node on the nodes array
//             nodes[indexToUse] = newNode;

//             //add the pointer to the member
//             members[member.walletAddress].slotIndex = indexToUse;

//             //push the new index to the upline invites array
//             members[msg.sender].invites.push(indexToUse);

//             //remove the node from the spillOverNodeArray
//             spillNodeArray[msg.sender][indexToRemove] = spillNodeArray[
//                 msg.sender
//             ][spillNodeArray[msg.sender].length - 1];
//             spillNodeArray[msg.sender].pop();

//             //remit tax to the greedy bastards:
//             shareTransactionFeeOfVNTToAdmin(msg.value);
//         } else {
//             require(1 == 2, "we can not insert a member at that position");
//         }
//     }

//     function generateSubNodeFromBinaryTree() public {
//         //check if the person is a member
//         Node[] memory subNodes;
//         uint8 subNodeLength;
//         Member memory findMember = members[msg.sender];
//         if (findMember.walletAddress != address(0)) {
//             //check if they have a slot number
//             uint256 slotIndex = findMember.slotIndex;
//             if (
//                 (slotIndex == 0 && findMember.walletAddress == ownerWallet) ||
//                 slotIndex != 0
//             ) {
//                 //this code will run if the slotIndex is 0 and the wallet address is the owner
//                 //or it will also run if the slotIndex is not zero
//                 Node memory startingNode = nodes[slotIndex];

//                 //add the node to the queue
//                 _enqueue(startingNode); //starting point

//                 while (head != tail) {
//                     // Get the index of the next node in the queue
//                     Node memory dequeueNode = _dequeue();
//                     //add to the final array to return here
//                     subNodes[subNodeLength] = dequeueNode;
//                     //increment subNodeLength
//                     subNodeLength++;

//                     //check left pointer
//                     if (dequeueNode.leftPointer != 0) {
//                         _enqueue(nodes[dequeueNode.leftPointer]);
//                     }
//                     //check right pointer
//                     if (dequeueNode.rightPointer != 0) {
//                         _enqueue(nodes[dequeueNode.rightPointer]);
//                     }
//                 }
//             }
//         }
//         //remove what was there before
//         delete memberSubNode[msg.sender];
//         for (uint256 i = 0; i < subNodes.length; i++) {
//             memberSubNode[msg.sender].push(subNodes[i]);
//         }
//     }

//     function retrieveSubNode() public view returns (Node[] memory) {
//         //return the generated sub node of the user;
//         return memberSubNode[msg.sender];
//     }

//     function _dequeue() private returns (Node memory) {
//         // If the queue is empty, throw an exception
//         require(head != tail, "Error: Queue is empty");

//         // Get the value of the front element
//         Node memory value = Nodequeue[head];

//         // Update the head index
//         head = (head + 1);

//         // Return the value of the removed node
//         return value;
//     }

//     // Define a function to add a new value to the end of the queue
//     function _enqueue(Node memory value) private {
//         // Add the new value to the end of the queue
//         Nodequeue[tail] = value;
//         // Update the tail index
//         tail = (tail + 1);
//     }

//     function _shareTokenFeeToAdmin(uint256 amount) private {
//         //20% and 80%
//         require(ownerWallet != address(0), "owner wallet not set");
//         require(adminWallet.length == 4, "set admin wallet");
//         bool success = VUSDTOKEN.transferFrom(
//             msg.sender,
//             ownerWallet,
//             (amount * 20) / 100
//         );
//         require(success);
//         for (uint256 i = 0; i < adminWallet.length; i++) {
//             bool success2 = VUSDTOKEN.transferFrom(
//                 msg.sender,
//                 adminWallet[i],
//                 (amount * 20) / 100
//             );
//             require(success2);
//         }
//     }

//     function _shareWithdrawalTaxFeeToAdmin(uint256 amount) private {
//         //20% and 80%
//         require(ownerWallet != address(0), "owner wallet not set");
//         require(adminWallet.length == 4, "set admin wallet");
//         bool success = VUSDTOKEN.transfer(ownerWallet, (amount * 20) / 100);
//         require(success);
//         for (uint256 i = 0; i < adminWallet.length; i++) {
//             bool success2 = VUSDTOKEN.transfer(
//                 adminWallet[i],
//                 (amount * 20) / 100
//             );
//             require(success2);
//         }
//     }

//     function shareTransactionFeeOfVNTToAdmin(uint256 amount) private {
//         //20% and 80%
//         require(ownerWallet != address(0), "owner wallet not set");
//         require(adminWallet.length == 4, "set admin wallet");
//         (bool success, ) = payable(address(this)).call{
//             value: (amount * 20) / 100
//         }("");
//         require(success, "VNT transfer failed");
//         for (uint256 i = 0; i < adminWallet.length; i++) {
//             (bool success2, ) = payable(address(this)).call{
//                 value: (amount * 20) / 100
//             }("");
//             require(success2, "vnt transfer 2 failed");
//         }
//     }

//     receive() external payable {}

//     function checkTokenBalance(address wallet) public view returns (uint256) {
//         return VUSDTOKEN.balanceOf(wallet);
//     }

//     function _setInitialPyramid(address owner) private {
//         //add the first value in the Node array
//         Node memory newNode;
//         newNode.memberAddress = owner;
//         newNode.index = currentIndex;
//         newNode.leftPointer = 0;
//         newNode.rightPointer = 0;

//         //save the node
//         nodes[currentIndex] = newNode;

//         //save the Member details
//         Member memory newMember;
//         newMember.directRefEarnings = 0;
//         newMember.invites = new uint256[](0);
//         newMember.walletAddress = owner;
//         newMember.slotIndex = currentIndex;
//         newMember.upline = address(0);
//         newMember.uplineIndex = 0;
//         newMember.membershipType = MembershipType.PLATINUM;
//         newMember.status = true;
//         newMember.clickRewardEarned = 0;
//         newMember.firstClickToday = 0;
//         newMember.clickCount = 0;
//         newMember.totalEarnings = 0;
//         newMember.moneyCalculatedLeft = 0;
//         members[owner] = newMember;
//         //increment the currentIndex
//         currentIndex++;
//     }

//     function calculateSMBBonus() public {
//         //generate the generateSubNodeFromBinaryTree();
//         generateSubNodeFromBinaryTree();
//         //get the generated subTree from the mapping
//         Node[] memory subNode = memberSubNode[msg.sender];
//         uint256 smbPoints;
//         for (uint256 i = 0; i < subNode.length; i++) {
//             uint256 leftPointer = i * 2 + 1;
//             uint256 rightPointer = i * 2 + 2;
//             //check the points of the left pointer
//             if (
//                 subNode[leftPointer].leftPointer != 0 &&
//                 subNode[rightPointer].rightPointer != 0 &&
//                 subNode[leftPointer].points != 0 &&
//                 subNode[rightPointer].points != 0
//             ) {
//                 //smb match here
//                 smbPoints++;
//                 //decrement the right and left pointer points
//                 nodes[subNode[i].leftPointer].points =
//                     nodes[subNode[i].leftPointer].points -
//                     1;
//                 nodes[subNode[i].rightPointer].points =
//                     nodes[subNode[i].rightPointer].points -
//                     1;
//             }
//         }
//         //save the earned bonus
//         smbBonusEarned[msg.sender] = smbBonusEarned[msg.sender] + smbPoints;
//     }

//     function retrieveSMBBonusEarned() public view returns (uint256) {
//         //the calculateSMBBonus(); function must be called before calling the retrieveSMBBonusEarned();
//         return smbBonusEarned[msg.sender];
//     }

//     function clickToEarn() public payable nonReentrant {
//         require(
//             members[msg.sender].walletAddress != address(0),
//             "not a member"
//         );
//         require(msg.value >= transactionTax, "insufficient tax sent");
//         Member memory member = members[msg.sender];
//         uint256 allowedDailyClicks;
//         if (member.membershipType == MembershipType.ELITE) {
//             allowedDailyClicks = membershipPackagesArray[0].dailyClicks;
//         } else if (member.membershipType == MembershipType.PLATINUM) {
//             allowedDailyClicks = membershipPackagesArray[2].dailyClicks;
//         } else if (member.membershipType == MembershipType.PREMIUM) {
//             allowedDailyClicks = membershipPackagesArray[1].dailyClicks;
//         }

//         if (_advertClickIsWithin24Hours(member.firstClickToday)) {
//             //we can still click
//             require(
//                 member.clickCount <= allowedDailyClicks,
//                 "you can no longer click"
//             );
//             //add the click to the
//             members[msg.sender].clickRewardEarned += 1;
//             members[msg.sender].clickCount += 1;
//         } else {
//             //we need to reset the click here
//             members[msg.sender].firstClickToday = block.timestamp;
//             members[msg.sender].clickRewardEarned += 1;
//             members[msg.sender].clickCount = 1;
//         }

//         //share tax to greedy bastards
//         shareTransactionFeeOfVNTToAdmin(msg.value);
//     }

//     function _advertClickIsWithin24Hours(uint256 firstClick)
//         internal
//         view
//         returns (bool)
//     {
//         //check if firstClick is is within 24hrs
//         uint256 fs = firstClick + (1 days);
//         if (block.timestamp < fs) {
//             return true;
//         } else {
//             return false;
//         }
//     }

//     //Admin Function Starts Here //
//     function configureSMBBonusAndMinimumWithdrawal(
//         uint256 minWithdrawal,
//         uint256 smbBonusAllocation
//     ) public onlyOwner {
//         if (minimumWithdrawal > 0) {
//             minimumWithdrawal = minWithdrawal;
//         }
//         if (smbBonusAllocation > 0) {
//             smbBonus = smbBonusAllocation;
//         }
//     }

//     function setAdminDetails(
//         uint256[2] memory pricing,
//         uint256 tax,
//         uint256 adCost,
//         uint256 rewardForClicking
//     ) public onlyOwner {
//         if (pricing.length > 0) {
//             //set pricing here
//             for (uint8 i = 0; i < pricing.length; i++) {
//                 membershipPackagePriceArray[i] = pricing[i];
//             }
//         }

//         if (tax > 0) {
//             transactionTax = tax;
//         }

//         if (adCost > 0) {
//             advertCost = adCost;
//         }

//         if (rewardForClicking > 0) {
//             clickReward = rewardForClicking;
//         }
//     }

//     // function setMembershipPricing(uint256[2] memory pricing) public onlyOwner {
//     //     require(pricing.length == 2, "the pricing requires 3 element");
//     //     for (uint8 i = 0; i < pricing.length; i++) {
//     //         membershipPackagePriceArray[i] = pricing[i];
//     //     }
//     // }

//     function setAdminWallet(address[] memory wallets) public onlyOwner {
//         require(wallets.length == 4, "the wallet length should be 4");
//         for (uint8 i = 0; i < wallets.length; i++) {
//             adminWallet[i] = wallets[i];
//         }
//     }

//     // function setTransactionTax(uint256 amount) public onlyOwner {
//     //     transactionTax = amount;
//     // }

//     function setOwnerWallet(address wallet) public onlyOwner {
//         ownerWallet = wallet;
//     }

//     // function setAdvertCost(uint256 cost) public onlyOwner {
//     //     advertCost = cost;
//     // }

//     // function setClickReward(uint256 cost) public onlyOwner {
//     //     clickReward = cost;
//     // }

//     function setAdvertMemberFeePercentage(
//         uint8[2] memory advertFeeArray,
//         uint8[2] memory memberFeeArray
//     ) public onlyOwner {
//         if (advertFeeArray.length > 0) {
//             for (uint256 i = 0; i < advertFeeArray.length; i++) {
//                 advertFeePercentage[i] = advertFeeArray[i];
//             }
//         }

//         if (memberFeeArray.length > 0) {
//             for (uint256 i = 0; i < memberFeeArray.length; i++) {
//                 memberEntryPercentage[i] = memberFeeArray[i];
//             }
//         }
//     }

//     function setMembershipPackage(
//         uint256 index,
//         uint256 dailyClicks,
//         uint256 packagePoints,
//         uint256 maximumIncome
//     ) public onlyOwner {
//         require(
//             index <= membershipPackagesArray.length - 1,
//             "invalid array length"
//         );
//         MembershipPackage memory editMembershipPackage;
//         editMembershipPackage.dailyClicks = dailyClicks;
//         editMembershipPackage.packagePoints = packagePoints;
//         editMembershipPackage.maximumIncome = maximumIncome;
//         membershipPackagesArray[index] = editMembershipPackage;
//     }

//     //Admin Function Ends Here //
// }
